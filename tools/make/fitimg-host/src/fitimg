#!/usr/bin/perl
our $VERSION = "0.7.1";

# fitimg - (C)  2021-2022 Ralf Steines aka Hippie2000 - <hippie2000@webnmail.de>
# Handle and manipulate firmware images in AVM /var/tmp/fit-image format.
# Docs and latest version can be found at https://boxmatrix.info/wiki/FIT-Image

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

use strict;
use warnings; # requires perl 5.6
use Getopt::Std; # Perl core module (part of Perl package)
use String::CRC32; # May need 'cpan install String::CRC32'

# These are tools for trying to find out which sigature is in the FIT header.
# see a hexdump of a FIT image to see where the signature is located.
#use Crypt::Digest::MD5 qw(md5_hex);
#use Crypt::Digest::SHA256 qw(sha256_hex);
#use Crypt::Digest::SHA3_256 qw(sha3_256_hex);
#use Crypt::Digest::SHA512 qw(sha512_hex);
#use Crypt::Digest::SHA3_512 qw(sha3_512_hex);
#use Crypt::Digest::Whirlpool qw(whirlpool_hex);

# Freetz filenames
my %fname = (
	# HWR 261 - 4060
	261 => {
		'qcaarmv8_HW261_kernel' => 'kernel.image',
		'qcaarmv8_HW261_squashFS_filesystem' => 'filesystem.image',
		'qcaarmv8_HW261_flat_dt_0' => 'flatdt_0.image',
		'qcaarmv8_HW261_flat_dt_1' => 'flatdt_1.image',
		'qcaarmv8_HW261_flat_dt_2' => 'flatdt_2.image',
	},
	# HWR 257 - 5530
	257 => {
		'prxI_HW257_kernel' => 'kernel.image',
		'prxI_HW257_ramdisk' => 'filesystem.image',
		'prxI_HW257_flat_dt_0_aon' => 'flatdt_0_aon.image',
		'prxI_HW257_flat_dt_0_pon' => 'flatdt_0_pon.image',
		'prxB_HW0257_kernel' => 'kernel2.image',
		'prxB_HW0257_ramdisk' => 'filesystem2.image',
		'prxB_HW0257_flat_dt_0' => 'flatdt2_0.image',
	},
	# HWR 272 - 5590 ARM
	272 => {
		'qcaarmv8_HW272_kernel' => 'kernel.image',
		'qcaarmv8_HW272_flat_dt_0' => 'flatdt_0.image',
		'qcaarmv8_HW272_squashFS_filesystem' => 'filesystem.image',
	},
	# HWR 273 - 5590 PRX
	273 => {
		'prxI_HW273_kernel' => 'kernel2.image',
		'prxI_HW273_squashFS_filesystem' => 'filesystem2.image',
		'prxI_HW273_flat_dt_0_aon' => 'flatdt2_0_aon.image',
		'prxI_HW273_flat_dt_0_pon' => 'flatdt2_0_pon.image',
		'prxB_HW0273_kernel' => 'kernel3.image',
		'prxB_HW0273_ramdisk' => 'filesystem3.image',
		'prxB_HW0273_flat_dt_0' => 'flatdt3_0.image',
	},
	# HWR 256 - 7530ax
	256 => {
		'brcma9_HW256_kernel' => 'kernel.image',
		'brcma9_HW256_squashFS_filesystem' => 'filesystem.image',
		'brcma9_HW256_flat_dt_1' => 'flatdt_1.image',
		'brcma9_HW256_flat_dt_0' => 'flatdt_0.image',
		'brcma9TZ_HW256_kernel' => 'kernel2.image',
		'brcma9TZ_HW256_flat_dt_0' => 'flatdt2_0.image',
	},
	# HWR 253 - 6000
	253 => {
		'qcaarmv8_HW253_kernel' => 'kernel.image', 
		'qcaarmv8_HW253_squashFS_filesystem' => 'filesystem.image',
		'qcaarmv8_HW253_flat_dt_0' => 'flatdt_0.image',
		'qcaarmv8_HW253_flat_dt_2' => 'flatdt_2.image',
	},
	# HWR 268 - 1200ax - outer fit image
	"268.o" => {
		'maple_HW268_kernel' => 'kernel.image', # gets .fit extension
		'maple_HW268_squashFS_filesystem' => 'filesystem.image',
	},
	# HWR 268 - 1200ax - inner fit image
	268 => {
		'maple_HW268_kernel' => 'kernel.image', 
		'maple_HW268_flat_dt_0' => 'flatdt_0.image',
	},
	# HWR 271 - 7510 - outer fit image
	"271.o" => {
		'maple_HW271_kernel' => 'kernel.image', # gets .fit extension
		'maple_HW271_squashFS_filesystem' => 'filesystem.image',
	},
	# HWR 271 - 7510 - inner fit image
	271 => {
		'maple_HW271_kernel' => 'kernel.image', 
		'maple_HW271_flat_dt_0' => 'flatdt_0.image',
		'maple_HW271_flat_dt_2' => 'flatdt_2.image',
	},
);
my %missing = %fname;

# hunk types - word = 32bit, blob = binary
my %hunktype = (
	'#address-cells' => 'word',
	'algo' => 'string',
	'arch' => 'string',
	'avm,addresses' => 'word',
	'avm,data-align' => 'word',
	'avm,endianess' => 'string',
	'avm,gu-version' => 'word',
	'avm,kernel-args' => 'string',
	'avm,kernel_text_start' => 'word',
	'avm,names' => 'word',
	'avm,num_syms' => 'word',
	'avm,offsets' => 'word',
	'avm,relative_base' => 'word',
	'avm,token_index' => 'word',
	'avm,token_table' => 'word',
	'avm,variants' => 'string',
	'compression' => 'string',
	'data' => 'blob',
	'entry' => 'word',
	'fdt' => 'string',
	'info' => 'string',
	'kernel' => 'string',
	'load' => 'word',
	'os' => 'string',
	'ramdisk' => 'string',
	'squashFS' => 'string',
	'timestamp' => 'word',
	'type' => 'string',
	'value' => 'word',
);

# catch the terminating funktions
if (defined($ARGV[0])) {
	help() if $ARGV[0] =~ /^(-\?|--help)$/;
	version() if $ARGV[0] =~ /^(-v|--version)$/;
	release() if $ARGV[0] eq '--release'; # [--public] create release archive - BUMP $VERSION IN SECOND LINE AFTER!
}

# read the arguments: -l -t -x -r -c -s -h -o -d -p require an argument, -n -f and -q do not
my %opts;
my $see = "\nSee 'fitimg --help'";
getopts('l:t:x:r:c:s:h:o:d:p:nfqi', \%opts) or abort('invalid arguments' . $see);
abort('nothing to do - you need to pass one of -l -t -x -r -s or -h' . $see) if !$opts{l} && !$opts{t} && !$opts{x} && !$opts{r} && !$opts{c} && !$opts{s} && !$opts{h};
abort('don\'t mix -l -t -x -r -c -s and -h - only use one of them' . $see) if defined($opts{l}) + defined($opts{t}) + defined($opts{x}) + defined($opts{r}) + defined($opts{c}) + defined($opts{s}) + defined($opts{h}) > 1;
abort('replace (-r) and copy (-c) require an output file (-o)' . $see) if ($opts{r} || $opts{c}) && !$opts{o};
abort('input and output file must not be the same' . $see) if ($opts{r} && ($opts{o} eq $opts{r})) || ($opts{c} && ($opts{o} eq $opts{c}));
abort('padding can only be 0-1024 (kB)' . $see) if defined($opts{p}) && ($opts{p} > 1024 || $opts{p} < 0);

# read the source file into inbuf
my ($inbuf, $opt, $infile, $insize);
foreach $opt ('l', 't', 'x', 'r', 'c', 's', 'h') {
	$infile = $opts{$opt} if defined($opts{$opt});
}
open(INFILE, $infile) || abort("Can't open $infile");
binmode INFILE;
$insize = -s $infile;
read(INFILE, $inbuf, $insize);
close(INFILE);

# find the signature in inbuf
my $pos;
my $offset;
if ($inbuf =~ /\x0D\x00\xED\xFE.{76}\x00\x00\x00\x38/ms) { # 0x0d00edfe AVM signature + 0x00000038 @ offset 0x50
	$offset = $-[0];
	$pos = $offset + 0x80;
	my $fitsize = unpack('V', substr($inbuf, $offset + 4, 4)) + 0x50;
	my $fitsize2 = unpack('N', substr($inbuf, $offset + 0x4C, 4)) + 0x50;
	if ($offset > 0) {
		abort("fit-image size mismatch ($fitsize vs $fitsize), can't recover: $infile") if $fitsize != $fitsize2;
		abort("Truncated fit-image: $infile") if ($insize - $offset) < $fitsize;
		$insize = $fitsize + $offset;
		report(sprintf("found $fitsize bytes fit-image at offset 0x%08x", $offset));
	} else {
		abort("Truncated fit-image: $infile") if $insize < $fitsize;
	}
} else {
	abort("Signature not found - not an AVM fit-image: $infile");
}

# verify the passed source/target directory
my $dir = '';
if ((defined($opts{x}) || defined($opts{r})) && defined($opts{d})) {
	$dir = $opts{d};
	abort("Can't find directory: $dir") if !-e $dir;
	abort("Not a directory: $dir") if !-d $dir;
	$dir =~ s|([^/])$|$1/|g; # add trailing slash if missing
}

# get the hunk names from the description table
my $dbase = unpack('N', substr($inbuf, 0x54 + $offset, 4)) + 0x48;
my $dpos = 12; # add hunk header size
my $dbuf = substr($inbuf, $dbase + $dpos + $offset, $insize - $dbase - $dpos - 8); 
$dbuf =~ s/\0$//g;
my @desc = split(/\0/, $dbuf);
my ($dstr, %hunkname);
$hunkname{0} = 'info';
foreach $dstr (@desc) { 
	$hunkname{$dpos} = $dstr;
	$dpos += length($dstr) + 1; 
	print STDERR "### fitimg ### - unknown hunk type: $dstr, please report this!\n" if !$hunktype{$dstr};
}

# list the FIT headers in hexdump mode
if (defined($opts{h})) {
	report('# AVM Flattened Image Tree (FIT) header');
	report('');
	show($offset + 0x00, 4, 0, 0, "magic - always 0x0d00edfe", 1);
	show($offset + 0x04, 4, 0, 0, "totalsize - BE size of FIT - 0x50", 1);
	show($offset + 0x08, 4, 0, 0, "signature 0 - unknown - todo", 1);
	show($offset + 0x0C, 4, 0, 0, "signature 1 - unknown - todo", 1);
	show($offset + 0x10, 4, 0, 0, "signature 2 - unknown - todo", 1);
	show($offset + 0x14, 4, 0, 0, "signature 3 - unknown - todo", 1);
	show($offset + 0x18, 4, 0, 0, "signature 4 - unknown - todo", 1);
	show($offset + 0x1C, 4, 0, 0, "signature 5 - unknown - todo", 1);
	show($offset + 0x20, 4, 0, 0, "signature 6 - unknown - todo", 1);
	show($offset + 0x24, 4, 0, 0, "signature 7 - unknown - todo", 1);
	show($offset + 0x28, 4, 0, 0, "signature 8 - unknown - todo", 1);
	show($offset + 0x2C, 4, 0, 0, "signature 9 - unknown - todo", 1);
	show($offset + 0x30, 4, 0, 0, "signature 10 - unknown - todo", 1);
	show($offset + 0x34, 4, 0, 0, "signature 11 - unknown - todo", 1);
	show($offset + 0x38, 4, 0, 0, "signature 12 - unknown - todo", 1);
	show($offset + 0x3C, 4, 0, 0, "signature 13 - unknown - todo", 1);
	show($offset + 0x40, 4, 0, 0, "signature 14 - unknown - todo", 1);
	show($offset + 0x44, 4, 0, 0, "signature 15 - unknown - todo", 1);
#my $l = $insize;
#$l = unpack('N', substr($inbuf, 0x6C + $offset, 4));
#for my $i (0 .. 0x88) { 
#print "$i: " . md5_hex(substr($inbuf, $i + $offset, $l - $i)) . "\n";
#}
	report('');
	report('# Devicetree Blob (DTB) header');
	report('');
	show($offset + 0x48, 4, 0, 0, "magic - always 0xd00dfeed", 1);
	show($offset + 0x4C, 4, 0, 0, "totalsize - LE size of FIT - 0x50", 1);
	show($offset + 0x50, 4, 0, 0, "off_dt_struct - 0x80 - 0x48 = always 0x00000038", 1);
	show($offset + 0x54, 4, 0, 0, "off_dt_strings - LE pointer to descriptions base - 0x48", 1);
	show($offset + 0x58, 4, 0, 0, "off_mem_rsvmap - always 0x00000028", 1);
	show($offset + 0x5C, 4, 0, 0, "fdt version - always 0x00000011 = 17", 1);
	show($offset + 0x60, 4, 0, 0, "last compatible version - always 0x00000010 = 16", 1);
	show($offset + 0x64, 4, 0, 0, "boot_cpuid - always 0x00000000", 1);
	show($offset + 0x68, 4, 0, 0, "size_dt_strings - size of descriptions array", 1);
	show($offset + 0x6C, 4, 0, 0, "size_dt_struct - size of FIT body structure", 1);
	show($offset + 0x70, 4, 0, 0, "padding/reserved 0 - always 0x00000000", 1);
	show($offset + 0x74, 4, 0, 0, "padding/reserved 1 - always 0x00000000", 1);
	show($offset + 0x78, 4, 0, 0, "padding/reserved 2 - always 0x00000000", 1);
	show($offset + 0x7C, 4, 0, 0, "padding/reserved 3 - always 0x00000000", 1);
	report('');
	report('# Devicetree Blob (DTB) structure');
}

# now parse the inbuf
my ($head, $type, $body, $strbuf, $string, $name, $len, $status, $blob, $blobsize, $loadaddr, $outbuf, %replaced, $didend, $oldpos);
my $errors = 0;
my $files = 0;
my $lastpos = $pos;
my $section = '';
my $realsect = '';
my $hwr = '';

while ($pos < $insize) {
	$oldpos = $pos;
	$head = unpack('N', substr($inbuf, $pos, 4));

	if ($head == 0) {
		$type = unpack('N', substr($inbuf, $pos + 4, 4));
		report('') if $opts{s};
		if ($type == 0) {
			show($oldpos, 0, 8, $head, 'hunk end');
			$pos += 8;
			$didend = 1;
		} else {
			show($oldpos, 0, 8, $head, '???');
			abort(sprintf("unknown hunk end $type @ 0x%08x", $pos));
		}
		if (defined($opts{r}) || defined($opts{c})) {
			$outbuf .= substr($inbuf, $lastpos, $pos - $lastpos);
			$lastpos = $pos;
		}
		last if $didend;

	} elsif ($head == 1) {
		$string = $strbuf = '';
		$pos += 4;
		do {	$strbuf = substr($inbuf, $pos, 4);
			$string .= $strbuf;
			$pos += 4;
		} until $strbuf =~ "\0";
		$string =~ s/\0//g;
		show($oldpos, $pos - $oldpos, 0, $head, "string = '$string'");
		$realsect = $section = $string if $string !~ /^hash_/;
		if ($section =~ /_HW0*(\d{3})_/) {
			$hwr = $1;
			$hwr .= '.o' if $hwr eq "268" && unpack('N', substr($inbuf, $offset + 0x68, 4)) == 0x9e; # outer fit image (1200ax)
			$hwr .= '.o' if $hwr eq "271" && unpack('N', substr($inbuf, $offset + 0x68, 4)) == 0x9e; # outer fit image (7510)
		}
		if (defined($opts{r}) || defined($opts{c})) {
			$outbuf .= substr($inbuf, $lastpos, $pos - $lastpos);
			$lastpos = $pos;
		}

	} elsif ($head == 2) {
		$string = $strbuf = '';
		$type = unpack('N', substr($inbuf, $pos+4, 4));
		for my $i (0 .. $type-1) { $pos += 4; }
		$pos += 4;
		$pos += 4 if unpack('N', substr($inbuf, $pos, 4)) == 1; # last before configurations
		$pos += 4 if unpack('N', substr($inbuf, $pos, 4)) == 9; # last before description
		do {	$strbuf = substr($inbuf, $pos, 4);
			$string .= $strbuf;
			$pos += 4;
		} until $strbuf =~ "\0";
		$string =~ s/\0//g;
		$realsect = $section = $string if $string !~ /^hash_/;
		if (($string eq 'description') && ($opts{s} || $opts{h})) {
			report('');
			report('# Devicetree Blob (DTB) strings');
		}
		show($oldpos, $pos - $oldpos, 0, $head, "string = '$string'");
		if ($section =~ /_HW0*(\d{3})_/) {
			$hwr = $1;
			$hwr .= '.o' if $hwr eq "268" && unpack('N', substr($inbuf, $offset + 0x68, 4)) == 0x9e; # outer fit image (1200ax)
			$hwr .= '.o' if $hwr eq "271" && unpack('N', substr($inbuf, $offset + 0x68, 4)) == 0x9e; # outer fit image (7510)
		}
		if ($section eq 'description') {
			report('') if $opts{s};
			$strbuf = substr($inbuf, $pos, $insize - $pos - 8);
			$strbuf =~ s/\0$//g;
			my @desc = split(/\0/, $strbuf);
			foreach $string (@desc) { 
				show($pos, length($string), 1, '->', "array[] = '$string'");
				$pos += length($string) + 1; 
			}
		}
		if (defined($opts{r}) || defined($opts{c})) {
			$outbuf .= substr($inbuf, $lastpos, $pos - $lastpos)    ;
			$lastpos = $pos;
		}

	} elsif ($head == 3) {
		$body = unpack('N', substr($inbuf, $pos + 4, 4));
		$type = unpack('N', substr($inbuf, $pos + 8, 4));
		$name = defined($hunkname{$type}) ? $hunkname{$type} : 'todo';

		if ($hunktype{$name} eq 'blob') { # blob
			show($oldpos, $body, 12, "$head #$type", "$name = <binary blob>");
			report('.... <snip> ....') if $opts{h};
			$section = $fname{$hwr}{$section} if defined($opts{f}) && defined($fname{$hwr}{$section});
			$blobsize = $body;
			$blob = substr($inbuf, $pos + 12, $body) if defined($opts{t}) || defined($opts{x}) || defined($opts{c});
			if (defined($opts{r})) {
				# the next line avoids a 2 pass interpreter since the info "type = 'avm,fit'" comes after the blob
				$section .= '.fit' if defined($opts{i}) && -s "$dir$section.fit";
				if (open(BLOB, "$dir$section")) { # fail silently
					binmode BLOB;
					$blobsize = -s "$dir$section";
					read(BLOB, $blob, $blobsize);
					close BLOB;
					report(sprintf("Replacing: %08d->%08d $section", $body, $blobsize));
					$outbuf .= pack('N', $head);
					$outbuf .= pack('N', $blobsize);
					$outbuf .= pack('N', $type);
					$outbuf .= $blob;
					$outbuf .= "\0" x (4 - $blobsize % 4) if $blobsize % 4; # padding
					$replaced{$section}++;
					$files++;
				}
			}
			delete $missing{$hwr}{$realsect} if $body + $pos < $insize;

		} elsif ($name eq 'load') { # loadaddr
			$loadaddr = unpack('N', substr($inbuf, $pos + 12, $body));
			show($oldpos, $body, 12, "$head #$type", sprintf("$name = 0x%08x", $loadaddr));
			report(sprintf("%08x-%08x %8d $section", $loadaddr, $loadaddr + $blobsize, $blobsize)) if defined($opts{l});

		} elsif ($name eq 'value') { # hashvalue (crc)
			my $crc1 = unpack('N', substr($inbuf, $pos + 12, $body));
			show($oldpos, $body, 12, "$head #$type", sprintf("$name = 0x%08x", $crc1));
			if (defined($opts{t}) || defined($opts{x}) || defined($opts{c})) {
				if (defined($opts{x})) {
					if (!defined($opts{n}) || $section !~ /flat_dt|flatdt/) {
						open(BLOB, ">$dir$section") || abort("Can't write to $dir$section");
						binmode BLOB;
						print BLOB $blob;
						close BLOB;
						$files++;
					}
				} else {
					$files++;
				}
				my $crc2 = crc32($blob);
				$status = $crc1 == $crc2 ? 'OK' : 'BAD';
				if (!defined($opts{n}) || $section !~ /flat_dt|flatdt/) {
					report(sprintf("$status: %08x %08x %8d $section", $crc1, $crc2, $blobsize));
				}
				$errors++ if $crc1 != $crc2;
			} elsif (defined($opts{r}) && defined($replaced{$section})) {
					$outbuf .= pack('N', $head);
					$outbuf .= pack('N', 4);
					$outbuf .= pack('N', $type);
					$outbuf .= pack('N', crc32($blob));
			}

		} elsif ($hunktype{$name} eq 'string') { # string
			$string = substr($inbuf, $pos + 12, $body);
			$string =~ s/\0//g;
			show($oldpos, $body, 12, "$head #$type", "$name = '$string'");

			if (defined($opts{r}) && defined($replaced{$section}) && ($name eq 'avm,kernel-args')) { # kernel-args
				my $newstring = '';
				if (($string =~ /^(.*)0x([0-9a-fA-F]{8}),0x([0-9a-fA-F]{8})(.*:)(\d+)(\@.*)$/)) {
					my $endaddr = hex($2) + $blobsize + ($blobsize % 0x100000 ? (0x100000 - $blobsize % 0x100000) : 0); # 1MB padding
					$newstring = sprintf($1."0x$2,0x%08x$4%d$6", $endaddr, $blobsize); 
				} elsif ($string) {
					warning("Can't adapt kernel-args '$string'\nThis image will not work, please report this!");
					$newstring = $string;
				}
				my $newlen = length($newstring) + 1;
				$outbuf .= pack('N', $head);
				$outbuf .= pack('N', $newlen);
				$outbuf .= pack('N', $type);
				$outbuf .= $newstring . "\0";
				$outbuf .= "\0" x (4 - $newlen % 4) if $newlen % 4; # padding
			}

			if ($name eq 'type' && $string eq 'avm,fit') { # inner fit image without crc
				$section .= '.fit' if defined($opts{i}) && ($section !~ /\.fit$/);
				if (defined($opts{t}) || defined($opts{x}) || defined($opts{c})) {
					if (defined($opts{x})) {
						open(BLOB, ">$dir$section") || abort("Can't write to $dir$section");
						binmode BLOB;
						print BLOB $blob;
						close BLOB;
						$files++;
					} else {
						$files++;
					}
					my $crc2 = crc32($blob);
					if (!defined($opts{n}) || $section !~ /flat_dt|flatdt/) {
						report(sprintf("??: ???????? %08x %8d $section ### inner fit-image without crc ###", $crc2, $blobsize));
					}
				}
			}

		} elsif ($hunktype{$name} eq 'word') { # 32-bit word
			my $word = unpack('N', substr($inbuf, $pos + 12, $body));
			show($oldpos, $body, 12, "$head #$type", defined($word) ? sprintf("$name = 0x%08x = %d", $word, $word) : "$name = <empty>");

		} else {
			show($oldpos, $body, 12, "$head #$type", 'todo');
		}

		$len = $body + 12 + ($body % 4 ? (4 - $body % 4) : 0); # add hunk head + padding
		$pos += $len;
		if (defined($opts{r}) || defined($opts{c})) {
			$outbuf .= substr($inbuf, $lastpos, $pos - $lastpos) unless defined($replaced{$section}) && ($name = $hunkname{$type}) && (($name eq 'data') || ($name eq 'value') || ($name eq 'avm,kernel-args'));
			$lastpos = $pos;
		}

	} else {
		abort(sprintf("unknown hunk head $head @ %08x", $pos));
	}

}

# write the header and outbuf and padding
if (defined($opts{r}) || defined($opts{c})) {
	my $lentotal = length($outbuf) + 0x80;
	my $lendiff = $lentotal - ($pos - $offset);

	my $padding = 1024 * (defined($opts{p}) ? $opts{p} : 64); # 64kB padding or override
	if ($padding && $lentotal % $padding) {
		$outbuf .= "\0" x ($padding - $lentotal % $padding);
	}

	open(OUTFILE, ">$opts{o}") || abort("Can't write to $opts{o}");
	binmode OUTFILE;
	print OUTFILE "\x0D\x00\xED\xFE"; # signature
	print OUTFILE pack('V', $pos - 0x50 - $offset + $lendiff);
	print OUTFILE substr($inbuf, 0x08 + $offset, 0x4C - 0x08);
	print OUTFILE pack('N', $pos - 0x50 - $offset + $lendiff);
	print OUTFILE substr($inbuf, 0x50 + $offset, 4);
	print OUTFILE pack('N', unpack('N', substr($inbuf, 0x54 + $offset, 4)) + $lendiff);
	print OUTFILE substr($inbuf, 0x58 + $offset, 0x6C - 0x58);
	print OUTFILE pack('N', unpack('N', substr($inbuf, 0x6C + $offset, 4)) + $lendiff);
	print OUTFILE substr($inbuf, 0x70 + $offset, 0x80 - 0x70);
	print OUTFILE $outbuf;
	close OUTFILE;
}

# check for truncated files or images with wrong EOF pointers
if ($hwr) {
	my $errs = 0;
	$errs++ unless $didend;
	foreach my $item (sort keys %{$missing{$hwr}}) { 
		print STDERR "### fitimg ### - missing blob '$item'\n";
		$errs++; 
	}
	abort("truncated fit image" . ($offset ? ' or wrong size info' : '')) if $errs;
}

# status reports
if (defined($opts{t}) || defined($opts{x}) || defined($opts{r}) || defined($opts{c})) {
	abort("BROKEN fit image") if $errors;
	if (!defined($opts{q})) {
		print "no errors in $files files\n" if defined($opts{t});
		print "extracted $files files\n" if defined($opts{x});
		print "replaced $files files\n" if defined($opts{r});
		print "no errors copying fit image containing $files files\n" if defined($opts{c});
	}
}

######## subroutines ########

# version or help options
sub version {
	print "fitimg version $VERSION - (C)  2021-2022 Ralf Steines aka Hippie2000 - <hippie2000\@webnmail.de>\n";
	print "Handle and manipulate firmware images in AVM /var/tmp/fit-image format. GPLv2+.\n";
	print "Docs and latest version can be found at https://boxmatrix.info/wiki/FIT-Image\n";
	exit unless $_[0];
}

# help option
sub help {
	version(1);
	print <<ENDHELP;

Usage:
  fitimg -l <infile> [-f] [-q]
    List all binaries contained in fit-image <infile>.
    Option -q could be used to silently test the image structure.

  fitimg -t <infile> [-f] [-q]
    Test the integrity of all binaries contained in fit-image <infile>. Performs CRC32 validation.
    Option -q could be used to silently test the image structure and checksum integrity.

  fitimg -x <infile> [-d <dir>] [-n] [-f] [-q]
    Extract all contents of fit-image <infile> or just <file> to current directory or <dir>.
    Option -i appends a .fit extension to the filename for inner fit images  (fitimg 0.7.1+)
    Option -n suppresses extracting device tree files.
    Option -q suppresses listing which files were extracted.

  fitimg -r <infile> -o <outfile> [-d <dir>] [-f] [-p <num>] [-q]
    Replace all contens of fit-image <infile> which exist in current directory or <dir> and write it to <outfile>.
    Files which do not exist in current directory or <dir> will not be replaced.
    Option -i includes inner image when creating outer FIT for nested FIT images (fitimg 0.7+)
    Option -p ovverrides the default padding size of 64 (0 - 1024) in kB  (fitimg 0.5+)
    Option -q suppresses listing which files were replaced.

  fitimg -c <infile> -o <outfile> [-f] [-p <num>] [-q]  (fitimg 0.2+)
    Copy an unaltered fit-image from <infile> to <outfile> while testing its integrity.
    This is mainly useful to extract and validate a fit-image from a recovery.exe or firmware.image.
    Option -p ovverrides the default padding size of 64 (0 - 1024) in kB  (fitimg 0.5+)
    Option -q could be used to silently copy and test the image structure and checksum integrity.

  fitimg -s <infile> [-q]  (fitimg 0.2+)
    Show the complete hunk structure of the fit-image <infile>.
    Option -q could be used to silently test the image structure

  fitimg -h <infile> [-q]  (fitimg 0.5+)
    Hexdump and show the complete structure of the fit-image <infile>.
    Hunk payload like binaries is clipped to 128 bytes, enough bytes to not clip kernel-args.
    Option -q could be used to silently test the image structure

Options:
  <infile> can be a fit-image, a firmware.image or a recovery.exe.  (fitimg 0.2+)
  -f activates Freetz mode using filesystem[2].image and kernel[2].image etc instead of the stored names.

  -? (fitimg 0.2+) or --help print this help text and terminates.
  -v (fitimg 0.2+) or --version print this program's version and terminates.

Result:
	Returns 1 on error, otherwise 0.
ENDHELP
	exit;
}

# quietable print
sub report {
	return if defined($opts{q});
	print "$_[0]\n";
}

# error handling
sub abort {
	print STDERR "### fitimg ### - $_[0]\n";
	exit 1;
}

# warnings
sub warning {
	print STDERR "fitimg: WARNING: $_[0]\n";
}

# create release archive
sub release {
	my $release = "fitimg-$VERSION";
	print "Creating release archive $release.tar.gz\n";
	system "mkdir -p ~/hosted/hippie2000/$release";
	system "cp -p ~/bin/fitimg ~/bin/COPYING ~/hosted/hippie2000/$release";
	system "~/bin/fitimg --help > ~/hosted/hippie2000/$release/readme.txt";
	system "cd ~/hosted/hippie2000 && tar cfvz $release.tar.gz $release";
	if (defined($ARGV[1]) && $ARGV[1] eq '--public') {
		system "chmod 644 ~/hosted/hippie2000/$release.tar.gz";
		system "ln -s -f $release.tar.gz ~/hosted/hippie2000/fitimg-latest.tar.gz";
		system "md5sum ~/hosted/hippie2000/$release.tar.gz";
	} else {
		system "chmod 600 ~/hosted/hippie2000/$release.tar.gz";
	}
	exit;
}

# show hunk - optionally with hexdump
sub show {
	return if (!$opts{s} && !$opts{h}) || $opts{q};
	my ($pos, $len, $len2, $hunk, $funct, $ishead) = @_;
	my $info = $ishead ? "  head [$len] - $funct\n" : "  hunk $hunk [$len] - $funct\n";
	my $count = 0;
	my $str = '';
	print "\n" if $funct =~ /string/ && $funct !~ /hash_/;
	$len += $len2;
	$len += 4 - $len % 4 if $len % 4 && $len2 != 1;
	$len = 128 if $len > 128;
	my $pre = ($pos - $offset) % 4;

	if (!$opts{h}) { 
		printf "%08x$info", $pos;

	} else { # hexdump
		print sprintf("%08x ", $pos - $pos % 4);
		if ($pos %4) {
			for my $i (1 .. $pos % 4) { $str .= '..'; }
		}
		while ($count < $len)  {
			$str .= sprintf("%02x", unpack('C', substr($inbuf, $pos + $count, 1)));
			$count++;
			if (($pos + $count) % 4 == 0 && $count <= $len) {
				$str .= $info;
				$str .= sprintf("%08x ", $pos + $count) unless $count == $len;
				$info = "\n";
			}
		}
		if (($pos + $len) % 4) {
			for my $i (1 .. 4 - ($pos + $len) % 4) { $str .= '..'; }
		}
		$str .= "\n" if $str !~ /\n$/;
		print $str;
	}
}


